---
globs: "*.py"
description: "Python coding standards and conventions for FastAPI projects"
---

# Python Coding Standards

## Core Standards

### String Literals

- **Always use double quotes**: `"string"` not `'string'`
- Apply consistently: variables, docstrings, imports, etc.

### Documentation Requirements

```python
"""Module description - every Python file starts with this."""

class TodoRequest(BaseModel):
    """Request model for todo creation and updates."""

async def get_todos(user: user_dependency):
    """Get all todos for the current user."""
```

### Error Handling Philosophy

- **No suppression comments**: Never use `# pylint: disable` or `# noqa`
- **Fix root causes**: Address the underlying issue, don't hide it
- **Custom exceptions**: Use domain-specific exceptions instead of generic ones

```python
# ✅ Good - Fix the issue
if user is None:
    raise NotAuthorized()

# ❌ Bad - Suppress the warning
raise HTTPException(status_code=401)  # pylint: disable=broad-exception-raised
```

### File Handling

```python
# Always specify encoding explicitly
with open("database.yml", "r", encoding="utf-8") as file:
    content = file.read()
```

### Type Hints

```python
from typing import Annotated, Optional, List
from fastapi import Depends
from sqlalchemy.orm import Session

# Use type hints for clarity and IDE support
async def get_todos(
    user: Annotated[dict, Depends(get_current_user)],
    db: Annotated[Session, Depends(get_db)]
) -> List[TodoResponse]:
    """Get all todos with proper type annotations."""
```

## Import Organization

### Standard Order (PEP 8 + isort)

```python
"""Module docstring."""

# 1. Standard library imports
from datetime import datetime, timedelta
from typing import Annotated, Optional

# 2. Third-party imports (alphabetical)
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session
from starlette import status

# 3. First-party imports (alphabetical)
from config import db_dependency, settings
from exceptions import NotAuthorized, RecordNotFound
from models import Todos, Users
from schemas import TodoRequest, TodoResponse, ValidId, ERROR_RESPONSES
```

### Consistent Import Patterns

```python
# ✅ Good - Centralized imports
from config import db_dependency, settings, setup_exception_handlers
from schemas import TodoRequest, ValidId, ERROR_RESPONSES

# ❌ Avoid - Inconsistent import sources
from config.database import db_dependency
from config.settings import settings
from schemas.common.common import ValidId
```

## Function and Class Design

### Single Responsibility Principle

```python
# ✅ Good - Each function has one clear purpose
async def get_todo(user: user_dependency, db: db_dependency, todo_id: ValidId):
    """Get a specific todo by ID."""

async def validate_todo_owner(todo: Todos, user_id: int):
    """Validate that user owns the todo."""

async def update_todo_fields(todo: Todos, todo_request: TodoRequest):
    """Update todo fields from request data."""

# ❌ Bad - Function doing too many things
async def get_and_update_todo_with_validation(user, db, todo_id, todo_request):
    """Get todo, validate ownership, update fields, save to database."""
```

### Clear Parameter Names

```python
# ✅ Good - Descriptive parameter names
async def create_todo(
    user: user_dependency,
    db: db_dependency,
    todo_request: TodoRequest
) -> TodoResponse:

# ❌ Bad - Unclear abbreviations
async def create_todo(u, db, req):
```

## Security Best Practices

### Authentication Patterns

```python
# ✅ Good - Consistent authentication checking
async def protected_endpoint(user: user_dependency):
    if user is None:
        raise NotAuthorized()
    # Continue with business logic

# ✅ Good - Role-based access control
async def admin_endpoint(user: user_dependency):
    if user is None:
        raise NotAuthorized()
    if user.get("user_role") != "admin":
        raise NotAuthorized("Admin access required")
```

### Password Handling

```python
# ✅ Good - Proper password hashing
bcrypt_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Hash on storage
hashed_password = bcrypt_context.hash(plain_password)

# Verify on login
if not bcrypt_context.verify(plain_password, stored_hash):
    raise NotAuthorized("Invalid credentials")
```

## Database Patterns

### Session Management

```python
# ✅ Good - Use dependency injection
async def get_todos(db: db_dependency):
    return db.query(Todos).all()

# ❌ Bad - Manual session management in routes
async def get_todos():
    db = SessionLocal()
    try:
        return db.query(Todos).all()
    finally:
        db.close()
```

### Query Patterns

```python
# ✅ Good - Clear, readable queries
todo = (
    db.query(Todos)
    .filter(Todos.id == todo_id)
    .filter(Todos.owner_id == user.get("id"))
    .first()
)

if todo is None:
    raise RecordNotFound("Todo not found")
```

This ensures consistent, secure, and maintainable Python code across the FastAPI application.
